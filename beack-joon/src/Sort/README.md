# Sort

## 버블 정렬

- 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하여 정렬하는 방식

**평균 O(n^2) ⇒ 비효율적**

## 선택 정렬

- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 구현이 복잡 ⇒ 코테에서 많이 안나옴

**평균 O(n^2) ⇒ 비효율적**

## 삽입 정렬

- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 구현하기 쉬움
- 선택데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 핵심(밀어내면서 정렬하는 느낌)

### 과정

1. 현재 index에 있는 값 선택
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색
3. 삽입 위치부터 index에 있는 위치까지 shift연산 수행
4. 삽입 위치에 현재 선택한 데이터를 삽입 index++ 연산 수행
5. 전체 데이터 크기만큼 index가 커질 때까지, 즉, 선택 데이터가 없을 때까지 반복
- 탐색 부분에서 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도 줄일 수 있음.

**평균 O(n^2) ⇒ 비효율적**

## 퀵 정렬

- 기준 값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
- pivot을 중심으로 데이터를 2개의 집합으로 나누면서 정렬하는 것이 핵심

### 과정

1. 데이터를 분할하는 pivot을 설정한다.
2. pivot을 기준으로 다음 a`~`e 과정을 거쳐 데이터를 2개의 집합으로 분리
2-a) start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동한다.
2-b) end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
2-c) start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다.
2-d) start와 end가 만날 때까지 2-a`~`2-c를 반복한다.
2-e) start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
3. 분리 집합에서 각각 다시 pivot을 선정한다.
4. 분리 집합이 1개 이하가 될 때까지 1`~`3을 반복한다.
- 시간 복잡도도 준수하여 코딩 테스트에서 종종 응용한다
- 재귀 함수의 형태로 직접 구현해보는 것을 추천
- Arrays.sort()가 이 방식을 응용하여 알고리즘 구현

**평균 O(nlog(n))**

## 병합 정렬

- 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
- 그룹을 나누어서 정렬하고 2개씩 그룹을 합치며 오름차순으로 정렬하는 것이 핵심
- 코딩 테스트에서 정렬 관련 문제로 자주 등장하는 정렬

### 과정

- 투 포인터 개념을 사용하여 왼쪽 -> 오른쪽 그룹을 병합.
- 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동.

**평균 O(nlog(n))**

## 기수 정렬

- 값을 비교하지 않는 특이한 정렬
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교
- 10개의 큐를 이용하여 각 자릿수에 해당하는 큐에 넣고 비교
- 큐라서 같은 자리라도 더 작은 자릿수가 작은 숫자가 먼저 나옴

**평균 O(kn) , k :  데이터의 자릿수**
